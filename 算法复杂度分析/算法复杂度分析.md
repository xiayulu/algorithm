# 如何衡量算法的优劣？

直观上，跑得快的算法比跑得慢的算法好，这里的“跑得快”可以用时间复杂度衡量。“跑得快”是一个性对的概念，显然64核128线程比2核4线程的 CPU 跑得快，同样的算法，用 C++ 实现的算法比用 Java 实现的跑得快，采用不同的编译器编译的程序运行时间也不同。这说明，算法的实际性能由许多因素决定，精确计算算法的运行时间是没有意义的。如何摆脱这些具体的影响因素来实现研究算法的复杂度呢？

实践表明，算法的运行时间是输入数据规模 $n$ 的函数 $f(n)$ 。常见的时间函数有：

- $c$ ：常数，随着数据规模的增长，算法的运行时间基本不变。
- $\log n$：对数，算法的运行时间是输入数据规模 $n$ 的对数函数。
- $n$：线性函数数，算法的运行时间是输入数据规模 $n$ 的线性函数。
- $n\log n$：次线性函数。
- $n^2, n^3$：平方与立方函数。
- $2^n$：指数，算法的运行时间是输入数据规模 $n$ 的指数函数。

- $n!$：阶层。



# 复杂度的阶

当 $n$ 很大的时候，有如下关系：
$$
n!\gg 2^n\gg n^3\gg n^2\gg n\log n\gg n\gg \log n\gg c
$$
运用极限的思想，当 $n$ 很大时，可以的出如下结论：

- $2^n$ 是比 $n^3$ 高阶的无穷大
- $2n$ 与 $3n$ 是同阶的无穷大
- $n^2+n\approx n^2$，即可以舍去低阶

因此，尽管实际的算法复杂度函数可能很复杂，但可以通过近似的方法，用比较简单的函数表示算法的复杂度。

- 复杂度下界：$\varOmega (g(n))$

$$
\exists n_0, \forall n\ge n_0, f(n)\ge cg(n)
$$

记为：
$$
f(n)=\varOmega(g(n))
$$

- 复杂度上界：$O(g(n))$
$$
\exists n_0, \forall n\ge n_0, f(n)\le cg(n)
$$

记为：
$$
f(n)=O(g(n))
$$
- 复杂度确界：$\Theta(g(n))$

$$
\exists n_0, \forall n\ge n_0, c_1g(n)\le f(n)\le c_2g(n)
$$

记为：
$$
f(n)=\Theta(g(n))
$$
以上关系可以简记为  $\ge, \le, =$ 

# 几种分析策略

对于同一个数据规模，算法的复杂度在一个范围内波动，即产生最好情况分析，最坏情况分析，平均情况分析。

在时间复杂度最好情况分析中，我们总是选取代价最小输入的案例。

在时间复杂度最坏情况分析中，我们总是选取代价最大输入的案例。

在时间复杂度平均情况分析中，我们需要知道每种输入的概率。



平摊分析：某些时候，我们无法用 $\Theta$ 符号估算复杂的确界，退而求其次，可以用 $O$ 估算，某些时候可能过高了，但可以得出最坏的情况下算法的实际表现可能要好。

# 空间复杂度

算法运行所需要的内存空间也是输入规模 $n$ 的函数，同样可以利用时间复杂度分析的方法进行分析。不过值得一提的是，空间复杂度与时间复杂可以对换，即可以通过牺牲空间换取时间，一个极端的例子是把所有可能的计算结果都保存起来，使用的时候就像查字典一样查询结果就行了，但是这样会耗费大量存储空间。

存储全部结果的意义不明显，但保存某些关键运算的结果是很有意义的，可以明显提高算法性能。请看如下两种斐波那契数列的实现方法：

```python
import time

# 0, 1, 1, 2, 3, 5, 8, ...


def fib1(n):
    if n <= 1:
        return n
    else:
        return fib1(n-1) + fib1(n-2)


def fib2(n):
    pre = 1
    ppre = 0
    curr = 0

    # fix fib2(1) == 1
    if n == 1:
        return 1

    while n > 1:
        curr = ppre + pre
        ppre = pre
        pre = curr
        n = n-1

    return curr


def time_cal(n, func):
    start = time.time()
    result = func(n)
    print(f'Get {result} use {time.time()-start}s')


time_cal(30, fib1)
time_cal(30, fib2)
```

运行结果：

```shell
Get 832040 use 2.0350022315979004s
Get 832040 use 7.3909759521484375e-06s
```

可见保存中间计算结果对计算性能的提升非常显著，这种策略叫**缓存**（cache）。

