考虑一个经典的斐波拉契数列问题：
$$
fib(n)=fib(n-1)+fib(n-2)
$$
在最开始我们讲到利用用缓存技术与利用递归技术相比，性能得到大幅度提升，这就是我们我们要学习的动态规划技术。与递归技术相比，动态规划有如下特点：

- 如果说递归是自顶向下，那么动态规划是自底向上的
- 动态规划会缓存中间计算结果，而递归每次调用函数计算


**动态规划（Dynamic Programming）**

- 基础知识：这里指的是用for循环方式的动态规划，非Memoization Search方式。DP可以在多项式时间复杂度内解决DFS需要指数级别的问题。常见的题目包括找最大最小，找可行性，找总方案数等，一般结果是一个Integer或者Boolean。动态规划有很多分支，暂时还没想好怎么去写这部分，后面想好了再具体写吧。

- 常见题目：

- - Leetcode 674 Longest Continuous Increasing Subsequence (接龙型dp)
  - Leetcode 62 Unique Paths II
  - Leetcode 70 Climbing Stairs
  - Leetcode 64 Minimum Path Sum
  - Leetcode 368 Largest Divisible Subset (接龙型dp)
  - Leetcode 300 Longest Increasing Subsequence (接龙型dp)
  - Leetcode 354 Russian Doll Envelopes (接龙型dp， 300的2D版)
  - Leetcode 256 Paint House
  - Leetcode 121 Best Time to Buy and Sell Stock
  - Leetcode 55 Jump Game
  - Leetcode 45 Jump Game II
  - Leetcode 132 Palindrome Partitioning II
  - Leetcode 312 Burst Balloons (区间型dp)
  - Leetcode 1143 Longest Common Subsequence (前缀型dp)
  - Leetcode 1062 Longest Repeating Substring (dp方法与longest common substring一致)
  - Leetcode 718 Maximum Length of Repeated Subarray (和1062本质上一样)
  - Leetcode 174 Dungeon Game
  - Leetcode 115 Distinct Subsequences
  - Leetcode 72 Edit Distance
  - Leetcode 91 Decode Ways
  - Leetcode 639 Decode Ways II
  - Leetcode 712 Minimum ASCII Delete Sum for Two Strings
  - Leetcode 221 Maximal Square
  - Leetcode 1277 Count Square Submatrices with All Ones (可以使用221一样的解法)
  - Leetcode 198 House Robber
  - Leetcode 213 House Robber II
  - Leetcode 740 Delete and Earn
  - Leetcode 87 Scramble String
  - Leetcode 1140 Stone Game II
  - Leetcode 322 Coin Change
  - Leetcode 518 Coin Change II (01背包型)
  - Leetcode 1048 Longest String Chain
  - Leetcode 44 [Wildcard Matching](https://link.zhihu.com/?target=https%3A//leetcode.com/problems/wildcard-matching)
  - Leetcode 10 [Regular Expression Matching](https://link.zhihu.com/?target=https%3A//leetcode.com/problems/regular-expression-matching)
  - Leetcode 32 Longest Valid Parentheses
  - Leetcode 1235 Maximum Profit in Job Scheduling (DP + binary search)
  - Leetcode 1043 Partition Array for Maximum Sum
  - Leetcode 926 Flip String to Monotone Increasing


# 最长递增子序列

【问题】给定一个规模为 $n$ 则整数序列 $A[1..n]$，按原顺序从中取一些数组成子序列，使之满足递增的规律，请给递增子序列的最大长度。

【示例】设有序列 10, 9, 2, 5, 3, 7, 101, 18，子序列 10, 101 与 2, 5, 7, 101 是递增子序列，最长子序列为 2, 5, 7, 101，其长度为 4。

【分析】对于以 $A[i]$ 结尾的最长递增子序列，设其长度为 $L_i$，那么对于以 $A[i+1]$ 结尾的最长子序列长度可按如下方法计算：

- 把 $A[i+1]$ 分别与$A[k]$ 比较 $k=1,2,\dots,i$
- 如果 $A[i+1]\le A[k]$，那么它不能扩展以 $A[k]$ 结尾的子序列，它自成一组，记 $L_{i+1}[k]=1$
- 如果 $A[i+1] \gt A[k]$，那么它能扩展以 $A[k]$ 结尾的子序列，因此记 $L_{i+1}[k]=L_k+1$

- 然后从 $L_{i+1}[1..i]$ 中选取最大的作为 $L_{i+1}$
- 整个序列的最长递增子序列等于 $\max(L_i), \quad i=1..n$

【复杂度】以上算法的复杂度是$O(n^2)$ 的。



# 背包问题

【问题】设有一个容量为 $C$ 的背包，现有 $n$ 个准备放入背包的物品，它们所占的空间为 $u_1,u_2,\dots,u_n$，它们拥有的价值为 $v_1, v_2,\dots,v_n$，请问怎样装才能获得最大价值的物品？

【分析】自然而然，我们先会装单位体积价值量大的物品，不过这是另外一个故事。现在用动态规划的方法解决这个问题的步骤如下：

1）用 $V[i,j]$ 表示用容量为 $j$ 背包装前 $i$ 个物品获得的最大值。$V[0,j]=0$，这是因为背包没有东西可装；$V[i,0]=0$，这是因为背包啥也装不下；原问题其实就是求 $V[n,C]$。

2）$V[i,j]$ 可以用如下递推式得到：
$$
V[i,j]=\begin{cases}
0	& i=0或j=0\\
V[i-1,j] &若j\lt u_i\\
\max(V[i-1,j], V[i-1,j-u_i]+v_i)&若j \ge u_i
\end{cases}
$$

【实现】
```python
def knapsack(U, V, c):
    n = len(U)

    Result = [[0 for i in range(c+1)] for j in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, c+1):
            Result[i][j] = Result[i-1][j]
            if U[i-1] <= j:  # U[i-1]: fix index from 0, i.e. U[i]
                # V[i-1]: fix index from 0, i.e. V[i]
                Result[i][j] = max(Result[i][j], Result[i-1][j-U[i-1]]+V[i-1]) 

    return Result[n][c]


U = [2, 3, 4, 5]
V = [3, 4, 5, 7]
c = 9

print(knapsack(U, V, c))
```

【小结】从以上两个例子可以看出动态规划是一个填表的过程，填写坐标比较大的点会用到坐标比较小的点的结果。



# 最长公共子序列

【问题】设有一个字符串 A：$a_1a_2\dots a_n$，从中取出一些字符按原顺序组成的新字符串称为它的一个子序列。例如 zx，zyy 都是 zxyxyz 的子序列。现有两个字符串 A 和 B，请求出它们最长公共子序列长度。

【分析】用 $L[i,j]$ 表示 $a_1a_2\dots a_i$ 和 $b_1b_2\dots b_j$ 最长公共子序列长度，它有如下一些性质：

- $L[i,j]=0$，如果 $i=0$ 或 $j=0$ ，空字符串的长度为零这很合理；
- $L[i,j]=L[i-1,j-1]+1$，如果 $a_i=b_j$， 相当于把最长公共子序列扩展了一位；
- $L[i,j]=\max(L[i-1,j],L[i,j-1])$，如果 $a_i\not= b_j$，不相同就取最大的。

【实现】

```python
def lcs(A, B):
    n = len(A)
    m = len(B)

    L = [[0 for i in range(m+1)] for j in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, m+1):
            if A[i-1] == B[j-1]:  # A[i-1], B[i-1]: fix index from 0
                L[i][j] = L[i-1][j-1]+1
            else:
                L[i][j] = max(L[i][j-1], L[i-1][j])

    return L[n][m]


A = "zxyxyz"
B = "xyyzx"

print(lcs(A, B))
```



# 小结

学习了动态规划之后，发现大部分工作就是填表，有的问题只与前面一行或一列有关，而有的问题需要参考前面许多行或列。

:bulb: 你能总结出用动态规划解决问题的模式吗?

