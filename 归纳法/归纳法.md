解决一个规模为 $n$ 的问题时，把问题规模转化为 $n-1$ 或 $n/2$ ，这种方法称为**归纳法**，归纳法带有明显的递归特征。以后要学习的分治算法与动态规划也属于归纳法的范畴。

# 选择排序

假设我们需要对含有 $n+1$ 个元素的数组 $A[0..n]$ 按从大到小排序。用归纳法解决问题的思路如下：

- 先找到 $A[0..n]$ 中的最大值 $A[j]$；
- 如果 $j\not=0$ 则交换 $A[0]$ 与 $A[j]$ ；

- 因此问题转化为对 $A[1..n]$ 的排序;

【实现】

```python
def find_max(A, i):
    j = i
    for k in range(0, len(A[i:])):
        if A[i+k] > A[j]:
            j = i+k
    return j


def select_sort(A, i):

    if i < len(A):
        j = find_max(A, i)
        if j != i:
            A[i], A[j] = A[j], A[i]
        select_sort(A, i+1)


A = [1, 2, 3, 2, 1, 3]
select_sort(A, 0)
print(A)
```

【输出】

```shell
[3, 3, 2, 2, 1, 1]
```

【解释】

- `A[i:]` 表示从 `A[i]` 到最后一个元素的子数组，即伪代码的 $A[i..n]$

- Python 函数参数是列表时，会修改原列表，相当于传递的是指针

【复杂度】

当数组规模为 $n$ 时，查找最大值的复杂度为 $n$，因此可以建立递推式：
$$
C(n)=
\begin{cases}
0&n=1\\
C(n-1)+n-1& n>1
\end{cases}
$$
解得 $C(n)=n(n-1)/2$，可以说此算法的复杂度是 $\Theta(n^2)$ 的。

# 插入排序

假设我们需要对含有 $n+1$ 个元素的数组 $A[0..n]$ 按从大到小排序。可以这样考虑：如果 $A[0..n-1]$ 是有序的，只需要把 $A[n]$ 插入到合适的位置 $j$ ，即：$A[j] \lt A[n] \lt A[j-1]$。

- 先备份 $tmp=A[n]$
- 对 $A[0..n-1]$排序，现在 $A[0,n-1]$ 是有序的了
- 找到合适的位置 $j$ ，即满足：$A[j] \lt A[n] \lt A[j-1]$
- 把 $A[j..n-1]$ 移动到 $A[j+1..n]$，令 $A[j]=tmp$

# 基数排序

【问题】设有一个规模为 $n+1$ 的数组 $A[0..n]$，它的每一个元素都是一个 $k$ 位数，即 $A[i]=\overline{d_k...d_1}$，请对该数组按从小到大排序。

【分析】这个问题可以用以上排序方法解决，这里提供另外一种思路。由于 $d_i(i=1,\dots,k)$ 可能为 0 到 9 中的任何一个数字，可以考虑把这些数按最高位分为 10 组：$A_0,A_1,\dots,A_9$，显然前面组里的数都要比后面的组小，但是组内的数的顺序却不固定。要是数组已经按照低 $k-1$ 位排好了序，那么组内的数也是有序的，可以考虑按照从低位到高位的顺序排序。

- 把数组元素按照最低位数字分到 10 个组 $A_0,A_1,\dots,A_9$ 里
- 依次从 $A_0,A_1,\dots,A_9$ 里取元素放回 $A$ 中，这时 $A$ 的元素已经按照最低位排好了序
- 按从次低位到最高位的顺序重复以上过程，此时 $A$ 已经排好了序。

```shell
7467  6792  1247  9187  1247
1247  3275  7467  1247  3275
3275  7467  3275  3275  6792
6792  1247  9187  7467  7467
9187  9187  6792  6792  9187
```

 

# 寻找多数元素

【问题】设有规模为 $n$ 的数组 $A[1..n]$，如果其中某个元素出现的次数大于 $\lfloor n/2 \rfloor$，则称它为多数元素，一个数组可能没有多数元素。例如：1, 3, 2, 3, 3, 4, 3 中 3 出现 4 次，因此为多数元素。

【分析】可以用蛮力法统计数组每个元素出现的次数，然后再看是否满足多数元素要求。这里还有一个优雅的解法：仔细观察发现多数元素有一个重要性质：原数组中去掉两个不同的元素后，得到一个新数组，他们的多数元素相同。

- 设置一个计数器 count = 1，并令候选元素为 candidate 为 $A[1]$
- 从 $A[2]$ 开始依次扫描数组，遇到相同元素 count 加一，否则减一
- 如果与 $A[j]$ 比较后 count 为零，对 $A[j+1..n]$ 重复上述过程
- 到最后如果 count 大于零，则返回候选元素
- 对最后返回的候选元素需要验证，如果满足要求才能接受。这一步是有必要的，这是因为如果最后剩下两个的元素相同，则无法辨别。

【实现】

```python
def candidate(A, i):
    c = A[i]
    count = 1
    j = i+1
    while count != 0:
        if c == A[j]:
            count += 1
        else:
            count -= 1

        j += 1
        if j == len(A):
            return c

    if j == len(A)-1:
        return A[-1]  # only the last one
    else:
        return candidate(A, j)


def majority(A):
    c = candidate(A, 0)
    count = 0
    for ele in A:
        if ele == c:
            count += 1
    return c if (count > len(A)//2) else None


testcases = [[1, 2, 3, 3, 3], [1, 1, 1, 3], [1, 2, 3, 3],
             [1, 1], [1, 2, 1, 1], [1, 2, 1, 2], [1, 3, 2, 3, 3]]
for A in testcases:
    print(majority(A))
```

【点评】这个算法实现起来其实一点也不优雅，不如用哈希表计数来得快，不过这种缩小问题规模的思路值得借鉴。

