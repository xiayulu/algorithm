回溯法（back track）是一种蛮力搜索方法，它的思想是尝试所有的可能解。想象你在一个迷宫里，你能做的就是在每个岔路口，尝试所有可能的路径，并做好标记。那么问题的复杂度就等于每个岔路口可选路径的乘积。回溯算法的只需要关注三个问题：

1、走过的路口：也就是已经做出的选择，有时也称为部分解向量，一般表示成：$c=(c_1, c_2, \dots, c_i)$。

2、可选择列表：也就是你当前可以做的选择，一般表示成 $X_i=\{x_1, x_2,\dots,x_l\}$。

3、结束的条件：评价部分解 $c$：如果是死胡同就返回上一个路口尝试另一条路径，如果是最终解，就成功返回。

代码框架：

```python
def backtrack(路径, 选择列表):
    if 满足结束条件:
        处理结果
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

# 排列生成

【问题】设有一个元素互不相等的序列 $A[1..n]$，请打印它所有的排列。

【分析】$A[1..n]$ 共有 $n!$ 个排列。怎样打印它的一个排列呢，可以利用洗牌的方法，洗一次打印一次，这样可以得到它的一些不同排列，但这个方法可能会导致重复与遗漏。有没有一个科学的组织方法来打印它的所有排列呢？

如果手动撸一个排列，我们会先固定前面的元素，把后面的排好之后再回来调整前面的元素，这就是回溯的思想了。用回溯思想解决问题的步骤如下：

- 首先固定第一个元素 $c_1$，即从它所有可能的取值 $X_1$ 中选一个，部分解 $c=(c_1)$；
- 然后固定第二个元素 $c_2$，即从它所有可能的取值 $X_2$ 中选一个，部分解 $c=(c_1,c_2)$；
- 固定好最后的元素 $c_n$ 后，打印最终解 $c=(c_1,c_2,\dots,c_n)$；
- 然后返回到上一层，从 $X_{n-1}$ 中选下一个可能的值，部分解 $c=(c_1,c_2,\dots,c_{n-1}')$；
- 重复以上过程直到每个元素都取完所有可能的值。

```python
X = {1, 2, 3}
c = []

def make_choices(c):
    return X-set(c)


def is_final_solution(c):
    return len(c) == len(X)

def permutation():
    if is_final_solution(c):
        print(c)
        return

    for x in make_choices(c):
        c.append(x)
        permutation()
        c.pop()


permutation()
```

【小结】以上代码 X 用 Python 集合数据结构可以方便的排除用过的元素。

# 生成子集

【问题】给定一个集合 $X=\{a_1,a_2,\dots,a_n\}$，请打印它的子集。

【分析】规模为 $n$ 的集合有 $2^n$ 个子集，这些集合中的元素是怎么挑选出来的呢，只需要知道一个元素在不在这个集合中，所以这个问题每个元素可能的取值是 $0,1$ 或 `True, False`。

```python
X = [1, 2, 3]
c = []


def make_choices():
    return [True, False]


def is_final_solution(k):
    return k == len(X)


def forward(x, c, k):
    if x:
        c.append(X[k])


def rollback(x, c, k):
    if x:
        c.pop()


def subset(k):
    if is_final_solution(k):
        print(c)
        return

    for x in make_choices():
        forward(x, c, k)
        subset(k+1)
        rollback(x, c, k)


subset(0)
```

【点评】以上代码进一步封装了两个函数，使得代码的结构更加清晰。

# 3 着色问题

【问题】设 $G=(V,E)$ 是一个连通无向图，用三种颜色给顶点着色，满足同一条边的两个顶点不同色。

【分析】把三种颜色编号为 1, 2, 3，那么每个顶点可能的着色为 $c_i\in X_i=\{1,2,3\}$。有 $n$ 个顶点的图共有 $3^n$ 种可能的着色方案。使用回溯方法搜索解的时候，需要判断部分解是否满足着色方案以决定要不要继续下一步。

# 八皇后问题

【问题】在 $8\times 8$ 的国际象棋棋盘上放置八个皇后，使得任何两个皇后不同行，不同列，不同对角线，请给出放置方案。

【分析】首先给八个皇后编号为 $0..7$，棋盘编号为 $(i,j),\quad i,j=0..7$，从零开始编号是为了方便实现。编好号之后某些抽象的概念就可用数学表达式表示了：

- “不同行与不同列”可以用 0..7 的一个排列表示，例如：2, 1, 0, 3, 6, 7, 5, 4 表示 0 号皇后在 $(2, 0)$，1 号在 $(1, 1)$，3 号在 $(0,3)$......即排列中次序表示皇后的编号与列数，那个位置上的数表示行号。
- 如果两个皇后在同一对角线上，那么有：$i_1-i_2=j_1-j_2$ 或 $i_1-i_2=j_2-j_1$

# 小结

你能总结出回溯算法的框架吗？

